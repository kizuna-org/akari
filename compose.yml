services:
  akari-db:
    image: postgres:18.1@sha256:bfe50b2b0ddd9b55eadedd066fe24c7c6fe06626185b73358c480ea37868024d
    container_name: akari-db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      NOCODB_DB: ${NOCODB_DB:-nocodb}
      TZ: UTC
    volumes:
      - db-store:/var/lib/postgresql
      - ./init-db:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  akari-migrate:
    build:
      context: .
      dockerfile: akari/Dockerfile.migrate
    container_name: akari-migrate
    restart: "no"
    depends_on:
      akari-db:
        condition: service_healthy
    environment:
      ENV: production
      POSTGRES_HOST: akari-db
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_SSLMODE: ${POSTGRES_SSLMODE}
    profiles:
      - migrate

  akari:
    build:
      context: .
      dockerfile: akari/Dockerfile
    container_name: akari
    restart: unless-stopped
    depends_on:
      akari-db:
        condition: service_healthy
    volumes:
      - ./secrets/akari-sa-key.json:/app/secrets/akari-sa-key.json
    environment:
      ENV: production
      # Database
      POSTGRES_HOST: akari-db
      POSTGRES_PORT: ${POSTGRES_PORT}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_SSLMODE: ${POSTGRES_SSLMODE}
      POSTGRES_MAX_OPEN_CONNS: ${POSTGRES_MAX_OPEN_CONNS}
      POSTGRES_MAX_IDLE_CONNS: ${POSTGRES_MAX_IDLE_CONNS}
      POSTGRES_CONN_MAX_LIFETIME_MINUTES: ${POSTGRES_CONN_MAX_LIFETIME_MINUTES}
      POSTGRES_CONN_MAX_IDLE_TIME_MINUTES: ${POSTGRES_CONN_MAX_IDLE_TIME_MINUTES}
      # LLM
      LLM_PROJECT_ID: ${LLM_PROJECT_ID}
      LLM_LOCATION: ${LLM_LOCATION}
      LLM_MODEL_NAME: ${LLM_MODEL_NAME}
      # Log
      LOG_LEVEL: ${LOG_LEVEL}
      LOG_FORMAT: ${LOG_FORMAT}
      # Discord
      DISCORD_TOKEN: ${DISCORD_TOKEN}
      DISCORD_READY_TIMEOUT: ${DISCORD_READY_TIMEOUT}
      # Akari
      DISCORD_BOTNAMEREGEXP: ${DISCORD_BOTNAMEREGEXP}
      # Others
      GOOGLE_APPLICATION_CREDENTIALS: /app/secrets/akari-sa-key.json
    healthcheck:
      test: ["CMD", "pgrep", "-f", "akari"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  nocodb:
    image: nocodb/nocodb:0.265.1@sha256:2fd72cb69ad59518c1fe23cc5cf74bd8c96ddff17aa67fc7b5febab499532db3
    container_name: nocodb
    restart: unless-stopped
    depends_on:
      akari-db:
        condition: service_healthy
    # Ports are not exposed to host for security reasons.
    # Cloudflare Tunnel is the only ingress point for external access.
    # Internal access within docker-compose network: http://nocodb:8080
    # If host port exposure is required, uncomment below and document the reason:
    # ports:
    #   - "8080:8080"
    environment:
      NC_DB: "pg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@akari-db:5432/${NOCODB_DB:-nocodb}"
      NC_AUTH_JWT_SECRET: ${NC_AUTH_JWT_SECRET}
      NC_SENTRY_DSN: ${NC_SENTRY_DSN:-}
      NC_DISABLE_TELE: ${NC_DISABLE_TELE:-true}
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  cloudflare-tunnel:
    image: cloudflare/cloudflared:2025.11.1@sha256:89ee50efb1e9cb2ae30281a8a404fed95eb8f02f0a972617526f8c5b417acae2
    container_name: cloudflare-tunnel
    restart: unless-stopped
    command: tunnel run
    environment:
      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}
    healthcheck:
      test: ["CMD", "cloudflared", "tunnel", "info"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

volumes:
  db-store:
    driver: local
